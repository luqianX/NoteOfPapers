# SSLGuard：一种用于自监督学习预训练编码器的水印方案

## 0.摘要

> * 与利用高质量标记数据集实现良好性能的监督学习相比，自监督学习依赖于未标记数据集来预训练强大的编码器，然后可以将其作为各种下游任务的特征提取器。
> * 大量的数据和计算资源消耗使得编码器本身成为模型所有者的宝贵知识产权。最近的研究表明，ML模型的版权受到模型窃取攻击的威胁，这种攻击旨在训练代理模型来模仿给定模型的行为。
> * 这是第一个用于预训练编码器的水印算法。给定一个干净的预训练编码器，SSLGuard将水印注入其中并输出带水印的版本。

## 1.简介

### 出发点

> * 自我监督学习（SSL）被提议通过从未标记的数据集（称为预训练数据集）生成“标签”来解决缺少标记数据的限制，并使用导出的“标签”对编码器进行预训练。
> * 高性能编码器通常由具有足够计算资源的领先AI公司预先训练，并通过云平台共享;
> * 面临威胁：
>   * 成员身份推断攻击（即，通过使用代理编码器离线安装成员身份推断）
>   * 后门攻击（即发布另一个后门编码器）
>   * 对抗样本。
> * 加水印SSL预训练编码器面临内在挑战
>   * 首先，针对分类器的模型水印通常需要在执行之前指定一个目标类，而SSL预训练的编码器没有此类信息。
>   * 其次，SSL预训练编码器的下游任务是灵活的，这挑战了仅适用于一个特定下游任务的传统模型水印方案。

### 作者工作

* 在本文中，我们首先通过模型窃取攻击来量化针对SSL预训练编码器的侵犯版权威胁。
* 然后，我们介绍了SSLGuard，这是第一个用于SSL预训练编码器的水印算法，以保护其版权。**请注意，在这项工作中，我们只考虑图像编码器。**
* 广泛的评估表明，SSLGuard在注入和提取水印方面有效，并且对模型窃取和其他水印移除攻击（如输入噪声、输出扰动、覆盖、模型修剪和微调）具有鲁棒性。

> ####  模型窃取攻击
>
> * 假设对手只能访问SSL预先训练的编码器（即受害者编码器）的黑匣子。对手的目标是构建一个替代编码器来“复制”受害者编码器的功能。
> * 将对手的背景知识描述为两个维度，即代理数据集的分布和代理编码器的架构。
>   * 对手可能知道或可能不知道受害者编码器的预训练数据集。
>   * 假设代理编码器与受害者编码器共享相同的架构。然后，放松这一假设，发现通过利用更大的模型架构，模型窃取攻击的有效性甚至可以提高。
>   * 窃取编码器的成本比从头开始预训练的成本小得多
>
> #### SSLGuard
>
> * 具体来说，给定一个秘密向量，SSLGuard的目标是将基于该秘密向量的水印注入到一个干净的SSL预训练编码器中。SSLGuard的输出包含一个带水印的编码器和一个密钥元组。具体来说，密钥元组由秘密向量、验证数据集和解码器组成。SSLGuard将干净的编码器微调为带水印的编码器。
> * 带水印编码器可以保留干净编码器的效用，并将验证数据集中的样本映射到秘密表示。我们还引入了一个解码器来将这些秘密表示转换为可能位于另一个空间中的秘密向量。对于其他编码器，解码器仅将从验证数据集生成的表示转换为随机向量。
>
> #### 鲁棒性测试
>
> * 对7个数据集（即ImageNet、CIFAR-10、CIFAR-100、STL-10、GTSRB、MNIST和FashionMNIST）和3个编码器预训练算法（即SimCLR、MoCo v2和BYOL）的经验评估表明，SSLGuard可以在不牺牲其性能的情况下成功地向SSL预训练编码器注入/提取水印，并且对模型窃取攻击具有鲁棒性。此外，我们考虑了各种类型的水印去除攻击，包括输入预处理（含噪）、输出扰动（含噪和截断）和模型修改（覆盖、修剪和微调）以“清理”模型。我们的经验表明，SSLGuard在这种情况下仍然有效。

## 3.威胁模型

### 攻击者动机

* 从头训困难；
* 省钱；

### 攻击者背景知识

* 对于对手，我们首先假设他们只有黑盒访问受害者编码器，这是对手最具挑战性的设置。在此设置中，对手只能使用数据样本查询受害者编码器，并获得其相应的响应，即嵌入。然后，使用数据样本和相应的响应来训练替代编码器。我们将对手的背景知识分为两个维度，即预训练数据集和受害者编码器的架构。具体来说，我们假设对手有一个查询数据集来执行攻击（查询数据集不需要与受害者编码器的预训练数据集处于相同的分布中）。
* 关于受害者编码器的架构，我们首先假设对手可以获得它，因为这样的信息通常是公开的。然后我们根据经验证明，这种假设可以放松，当代理编码器利用更深层的模型架构时，攻击甚至更有效。

### 适应性对抗

* 然后我们考虑一个自适应对手，他知道受害者编码器已经被加了水印。这意味着他们可以在受害者编码器上利用水印去除技术，包括输入预处理（噪声）、输出干扰（噪声和截断）以及模型修改（覆盖、修剪和微调），以绕过水印验证。

## 4.水印算法设计

> 保持以下性质：
>
> * 保真度
> * 有效性
> * 不可检测性
> * 效率
> * 鲁棒性

### 4.1 概览

* https://blog.csdn.net/qq_43141726/article/details/104943994伽马函数
* **数学原理**：给定一个与嵌入具有相同维度的向量，如果该向量被随机初始化，则这些嵌入与向量之间的平均余弦相似性应集中在零附近。然而，如果平均余弦相似度远大于0或甚至接近1，则这可以被认为是这些嵌入与该向量密切相关的信号。
* 防御者可以微调干净的编码器以将样本从Dv变换为嵌入，并训练解码器以将嵌入进一步变换为与sk具有高余弦相似性的解码向量。同时，如果防御者将这些验证样本输入干净的编码器，解码向量与sk之间的余弦相似性分布应该是以0为平均值的正态分布。

* 工作流程

![image-20221116224435925](.\appendix\001.png)

* 具体来说，我们首先训练一个包含验证数据集和秘密向量信息的带水印编码器。
  * 干净的编码器作为一个基于查询的API来指导培训过程。
  * 阴影编码器用于模拟模型窃取过程，以更好地保护模型窃取攻击下的水印。
  * 带水印的编码器应保持干净编码器的效用，同时保留注入其中的水印。

<img src=".\appendix\002.png" alt="image-20221116225157251" style="zoom: 150%;" />

### 4.2 准备

* 为了给预先训练的编码器加水印，防御者应该准备一个私有数据集$D_p$、一个掩码$M$和一个随机触发器$T$。

### 4.3 水印注入

* $\mathcal L_2$的作用是确保密钥的最终解释权在model主人手上，有点数字签名的意思；
* 整个训练过程在对抗训练；

## 5.评估

### 5.1 实验设置

？对抗学习预训练

### 5.2 干净的下游准确性

### 5.3 模型窃取攻击

由于SSL预训练编码器（干净编码器）功能强大，因此我们评估它们是否容易受到模型窃取攻击。为了构建代理编码器，我们考虑三个关键信息，即代理编码器的架构、查询数据集的分布以及用于“复制”受害编码器的相似性函数。

* **代理编码器架构**：
* **查询数据集分布**：如果对手知道下游任务，他们可以构建一个接近下游任务的查询数据集，以提高窃取性能。
* **相似性函数**：
* **成本**：

### 5.4 SSLGuard

> 在本节中，我们采用SSLGuard将水印注入到SimCLR、MoCo v2和BYOL预训练的干净编码器中。我们旨在验证SSLGuard的四个特性，即有效性、实用性、不可检测性和效率。我们将在第5.5节中单独讨论SSLGuard的鲁棒性。

* **有效性**：
* **保真度**：我们观察到，带水印编码器的DA几乎与干净编码器相同。例如，与Fsimclr相比，Fsimclr的DA∗ 仅从CDA下降至0.009。评估表明，我们的水印算法SSLGuard不会在不同的下游任务上牺牲干净编码器的效用。
* **不可检测性**：
* **效率**：

### 5.5 鲁棒性

#### 5.5.1 输入预处理

* 解释：$D_v$分布太特殊了;

#### 5.5.2 输出扰动

* 输出噪声
* 截断：攻击者无法在保留其功能的同时从编码器中移除水印。

#### 5.5.3 模型修改

> 当攻击者具有对编码器的白盒访问权限时，他们可以尝试通过修改编码器的参数来删除水印。在本节中，我们将考虑三种模型修改方法：水印覆盖、模型修剪和微调。

* 覆盖：攻击者还可以利用SSLGuard向SSL编码器注入新的水印，无论他们是否知道编码器已经注入了水印。
* 修剪：修剪是一种有效的模型压缩技术[59]。这也被认为是水印去除攻击，因为许多神经元可能被禁用，从而降低了水印的有效性[37]。在全局修剪设置中，我们将在所有层中具有最小绝对值的卷积层的权重的r分数设置为0。与全局修剪相比，即将不同层之间的所有连接放在一起并进行比较，局部修剪旨在修剪同一层中绝对值最小的一部分连接。
* 微调：修剪后，对手可以在受害者编码器的监督下微调代理编码器，这遵循[26]中的设置。这个过程也称为精细修剪[35]。微调的目标是恢复DA的下降。我们通过MSE损失函数微调修剪编码器（全局和局部）的所有权重。

？为什么冻结batchnorm层。

#### 5.5.4 模型窃取

* 尽管模型窃取攻击对带水印的编码器有效，但我们仍然可以验证代理模型的所有权，因为WR也很高。

## 6.讨论

* **Shadow Encoder的必要性**：这里其实是有些奇怪的，shadow encoder的训练过程其实引入一个对抗的损失可能更好；
* **掩模选择**：SSLGuard在不同掩模下是有效的；
* **到其他类型数据集的扩展**：

## 7.相关工作

## 8.结论

在本文中，我们首先通过模型窃取攻击的视角来量化SSL预训练编码器的版权破坏威胁。我们的经验表明，SSL预训练编码器极易受到模型窃取攻击。这是因为可以利用嵌入中的丰富信息来更好地捕获受害者编码器的行为。为了保护SSL预训练编码器的版权，我们提出了SSLGuard，一种用于SSL预训练的编码器的鲁棒黑盒水印算法。具体地说，给定一个秘密向量，SSLGuard将水印注入一个干净的预训练编码器，并输出一个带水印的版本。阴影训练技术也被应用于在潜在的模型窃取攻击下保持水印。广泛的评估表明，SSLGuard在嵌入和提取水印方面有效，并且对模型窃取和不同类型的水印移除攻击（如输入噪声、输出扰动、覆盖、模型修剪和微调）具有鲁棒性。

## 

